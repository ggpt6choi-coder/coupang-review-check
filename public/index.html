<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>쿠팡 리뷰 크롤러 대시보드</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>

<body>
    <div class="container">
        <header>
            <h1>🚀 Coupang Crawler <span>v1.0</span></h1>
            <p><span class="twinkle">므인뚜엉</span>도 쉽게 사용하는 프리미엄 리뷰 수집기</p>
        </header>

        <main>
            <section class="config-card">
                <h2>⚙️ 크롤링 설정</h2>

                <!-- 카테고리 ID: 태그 입력 방식 -->
                <div class="input-group full-width">
                    <label>카테고리 ID (숫자 입력 후 엔터) 예시:https://www.coupang.com/np/categories/<span
                            style="color:red">403222</span>?traceId=mltg9ov1</label>
                    <div id="tagContainer" class="tag-container">
                        <input type="text" id="tagInput" placeholder="ID 입력 후 Enter">
                    </div>
                </div>

                <div class="form-grid">
                    <div class="input-group">
                        <label>최소 가격 (원)</label>
                        <input type="number" id="minPrice" value="20000">
                    </div>
                    <div class="input-group">
                        <label>최대 가격 (원)</label>
                        <input type="number" id="maxPrice" value="50000">
                    </div>
                    <div class="input-group">
                        <label>페이지 수(페이지당 상품 60개)</label>
                        <input type="number" id="maxPages" value="2">
                    </div>
                    <div class="input-group">
                        <label>리뷰기간 (최근 며칠 이내)</label>
                        <input type="number" id="reviewDays" value="30">
                    </div>
                    <div class="input-group">
                        <label>리뷰페이지 (페이지당 10개)</label>
                        <input type="number" id="checkPage" value="20">
                    </div>
                </div>
                <div class="button-group">
                    <button id="startBtn" class="primary-btn">크롤링 시작하기</button>
                    <button id="stopBtn" class="danger-btn" style="display: none;">수집 중단</button>
                    <button id="downloadBtn" class="secondary-btn">결과 다운로드</button>
                    <button id="clearBtn" class="outline-btn">데이터 초기화</button>
                    <button id="shutdownBtn" class="dark-btn">서비스 종료</button>
                </div>
            </section>

            <section class="log-card">
                <div class="section-header">
                    <h2>🖥️ 실시간 진행 상태</h2>
                    <div class="stats-badge">총 수집: <span id="totalCount">0</span>건</div>
                </div>
                <div id="terminal" class="terminal"></div>
            </section>
        </main>
    </div>

    <script>
        const terminal = document.getElementById('terminal');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const clearBtn = document.getElementById('clearBtn');
        const shutdownBtn = document.getElementById('shutdownBtn');
        const totalCountDisplay = document.getElementById('totalCount');

        // 태그 관리
        const tagContainer = document.getElementById('tagContainer');
        const tagInput = document.getElementById('tagInput');
        let categoryTags = [419509];

        // localStorage 저장/로드 함수
        const STORAGE_KEY = 'coupang_crawler_config';

        function saveConfigToStorage() {
            const config = {
                categories: categoryTags,
                minPrice: document.getElementById('minPrice').value,
                maxPrice: document.getElementById('maxPrice').value,
                maxPages: document.getElementById('maxPages').value,
                reviewDays: document.getElementById('reviewDays').value,
                checkPage: document.getElementById('checkPage').value // Corrected ID from reviewCheckPages to checkPage
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
        }

        function loadConfigFromStorage() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const config = JSON.parse(saved);
                    categoryTags = config.categories || [419509];
                    if (config.minPrice) document.getElementById('minPrice').value = config.minPrice;
                    if (config.maxPrice) document.getElementById('maxPrice').value = config.maxPrice;
                    if (config.maxPages) document.getElementById('maxPages').value = config.maxPages;
                    if (config.reviewDays) document.getElementById('reviewDays').value = config.reviewDays;
                    if (config.checkPage) document.getElementById('checkPage').value = config.checkPage; // Corrected ID
                } catch (err) {
                    console.error('설정을 불러오는데 실패했습니다.', err);
                }
            }
        }

        function renderTags() {
            // 입력창 제외한 기존 태그 삭제
            const existingTags = tagContainer.querySelectorAll('.tag');
            existingTags.forEach(tag => tag.remove());

            categoryTags.forEach(tag => {
                const tagEl = document.createElement('span');
                tagEl.className = 'tag';
                tagEl.innerHTML = `${tag}<span class="tag-close" data-tag="${tag}">&times;</span>`;
                tagContainer.insertBefore(tagEl, tagInput);
            });
        }

        tagInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                const val = parseInt(tagInput.value.trim());
                if (val && !categoryTags.includes(val)) {
                    categoryTags.push(val);
                    tagInput.value = '';
                    renderTags();
                }
            } else if (e.key === 'Backspace' && tagInput.value === '' && categoryTags.length > 0) {
                categoryTags.pop();
                renderTags();
            }
        });

        tagContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('tag-close')) {
                const tagToRemove = parseInt(e.target.getAttribute('data-tag'));
                categoryTags = categoryTags.filter(t => t !== tagToRemove);
                renderTags();
                saveConfigToStorage(); // 태그 삭제 시에도 저장
            } else {
                tagInput.focus();
            }
        });

        loadConfigFromStorage(); // 저장된 설정 불러오기
        renderTags(); // 초기 렌더링

        // 로그 추가 함수
        function appendLog(msg, type = 'normal') {
            const line = document.createElement('div');
            line.className = `log-line ${type}`;
            line.textContent = msg;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function setRunningState(isRunning) {
            if (isRunning) {
                startBtn.style.display = 'none';
                stopBtn.style.display = 'block';
                stopBtn.disabled = false;
                stopBtn.textContent = '수집 중단';
            } else {
                startBtn.style.display = 'block';
                startBtn.disabled = false;
                startBtn.textContent = '크롤링 시작하기';
                stopBtn.style.display = 'none';
            }
        }

        // 실시간 로그 서버 연결 (SSE)
        const eventSource = new EventSource('/api/logs');
        eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'stats') {
                totalCountDisplay.textContent = data.count;
            } else if (data.type === 'text') {
                appendLog(data.message);

                // 완료 또는 중단 메시지 감지 시 버튼 원복
                if (data.message.includes('[완료]') || data.message.includes('[중단]') || data.message.includes('[치명적 오류]')) {
                    setRunningState(false);
                }
            }
        };

        // 크롤링 시작 버튼 클릭
        startBtn.addEventListener('click', async () => {
            if (categoryTags.length === 0) {
                alert('최소 하나 이상의 카테고리 ID를 입력해주세요.');
                return;
            }

            saveConfigToStorage(); // 시작 시 설정 저장

            const config = {
                categories: categoryTags,
                minPrice: parseInt(document.getElementById('minPrice').value),
                maxPrice: parseInt(document.getElementById('maxPrice').value),
                maxPages: parseInt(document.getElementById('maxPages').value),
                reviewDays: parseInt(document.getElementById('reviewDays').value),
                checkPage: parseInt(document.getElementById('checkPage').value),
                resultFile: 'result.json'
            };

            setRunningState(true);
            appendLog('▶️ 크롤링 명령을 전송했습니다...', 'system');

            try {
                const res = await fetch('/api/start-crawl', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                const result = await res.json();
                appendLog(`✅ ${result.message}`, 'system');
            } catch (err) {
                appendLog(`❌ 오류: ${err.message}`, 'error');
                setRunningState(false);
            }
        });

        // 수집 중단 버튼 클릭
        stopBtn.addEventListener('click', async () => {
            stopBtn.disabled = true;
            stopBtn.textContent = '🛑 중단 요청 중...';
            appendLog('⚠️ 중단 요청을 전송했습니다. 현재 상품 처리 후 멈춥니다...', 'system');

            try {
                await fetch('/api/stop-crawl', { method: 'POST' });
            } catch (err) {
                appendLog(`❌ 중단 요청 실패: ${err.message}`, 'error');
                setRunningState(false);
            }
        });

        // 결과 다운로드 버튼 클릭
        downloadBtn.addEventListener('click', () => {
            const count = parseInt(totalCountDisplay.textContent);
            if (count === 0) {
                alert('수집된 데이터가 없습니다. 먼저 크롤링을 시작해 주세요.');
                return;
            }
            window.location.href = '/api/download-results';
        });

        // 데이터 초기화 버튼 클릭
        clearBtn.addEventListener('click', async () => {
            if (!confirm('정말로 모든 수집 데이터를 초기화하시겠습니까? (삭제된 데이터는 복구할 수 없습니다.)')) {
                return;
            }

            try {
                const res = await fetch('/api/clear-results', { method: 'POST' });
                const result = await res.json();
                if (result.success) {
                    appendLog('🧹 데이터가 초기화되었습니다.', 'system');
                }
            } catch (err) {
                appendLog(`❌ 초기화 실패: ${err.message}`, 'error');
            }
        });

        // 서비스 종료 버튼 클릭
        shutdownBtn.addEventListener('click', async () => {
            if (!confirm('서비스를 종료하시겠습니까? (서버와 크롬 브라우저가 모두 닫힙니다.)')) {
                return;
            }

            try {
                const res = await fetch('/api/shutdown', { method: 'POST' });
                const result = await res.json();
                if (result.success) {
                    appendLog('👋 서비스 종료 요청을 보냈습니다. 2초 후 창이 닫힙니다.', 'system');
                    setTimeout(() => window.close(), 2000);
                }
            } catch (err) {
                appendLog(`❌ 종료 실패: ${err.message}`, 'error');
            }
        });
    </script>
</body>

</html>